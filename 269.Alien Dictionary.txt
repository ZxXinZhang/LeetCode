// Using topologic sort. "map" is to build graph. "degree" is used to store the indegree of nodes.
//Compare the adjacent strings by character. When we meet the first different character, we can make sure the character in the first string is before the character in the second string. Then break, since the second different character does not make sense about the order.
//There are two special cases we should consider. cur:abc  next:ab , cur:ab next:abc
//After we build the graph, we use topological sort to build the path.
//In the end, we have to make sure the path is true, so we should see if result.length() ?= degree.size(). If not, return "".
public class Solution {
 public String alienOrder(String[] words) {
    Map<Character, Set<Character>> map=new HashMap<Character, Set<Character>>();
    Map<Character, Integer> degree=new HashMap<Character, Integer>();
    String result="";
    if(words==null || words.length==0) return result;
    for(String s: words){
        for(char c: s.toCharArray()){
            degree.put(c,0);
        }
    }
    for(int i=0; i<words.length-1; i++){
        String cur=words[i];
        String next=words[i+1];
        int length=Math.min(cur.length(), next.length());
        for(int j=0; j<length; j++){
            char c1=cur.charAt(j);
            char c2=next.charAt(j);
            if(c1!=c2){
                Set<Character> set=new HashSet<Character>();
                if(map.containsKey(c1)) set=map.get(c1);
                if(!set.contains(c2)){
                    set.add(c2);
                    map.put(c1, set);
                    degree.put(c2, degree.get(c2)+1);
                }
                break;
            }else {
                if(j+1 <= cur.length()-1 && j+1 > next.length()-1) return "";
        }
        }
    }
    Queue<Character> q=new LinkedList<Character>();
    for(char c: degree.keySet()){
        if(degree.get(c)==0) q.add(c);
    }
    while(!q.isEmpty()){
        char c=q.remove();
        result+=c;
        if(map.containsKey(c)){
            for(char c2: map.get(c)){
                degree.put(c2,degree.get(c2)-1);
                if(degree.get(c2)==0) q.add(c2);
            }
        }
    }
   
    if(result.length()!=degree.size()) return "";
    return result;
}
}

